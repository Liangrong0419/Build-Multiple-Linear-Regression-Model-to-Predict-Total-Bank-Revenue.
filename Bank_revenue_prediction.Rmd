---
title: "R Notebook"
output: html_notebook
---

## Background
A bank wants to understand how customer banking habits contribute to revenues and profitability.  The bank has customer age and bank account information.
The goal is to build a model that allows the bank to predict profitability for a given customer.  A surrogate for customer profitability available in our data set is the Total Revenue a customer generates through their accounts and transactions.  The resulting model will be used to forecast bank revenues and guide the bank in future marketing campaigns.
(Rev_Total : Total revenue generated by the customer over a 6 month period)

```{r}
library(corrplot)
library(MASS)
library(skimr)
library(VIF)
library(fastDummies)
library(janitor)
library(tidyverse)
```

```{r}
#Import the data
bank_revenue <- read.csv("./bankrevenue.csv") %>%
  clean_names()
skim_without_charts(bank_revenue)
```
```{r}
# data cleaning: remove the $ sign and comma from the two character variables and change their data type as numeric. 

bank_revenue$bal_total <- gsub('[$]','',bank_revenue$bal_total)
bank_revenue$bal_total <- as.numeric(gsub(',','',bank_revenue$bal_total))
bank_revenue$rev_total <- gsub('[$]','',bank_revenue$rev_total)
bank_revenue$rev_total <- as.numeric(gsub(',','',bank_revenue$rev_total))
```

Step 1: exploratory data
```{r}
#our data set has fewer than 25 explanatory variables.
#generate the correlation/scatter plot matrices
cormat <- cor(bank_revenue) %>%
round(2)
cormat

library(corrplot)
corrplot(cormat)
```
As we can see from the plot above, there is not a strong correlation between predict variables and response variable (rev_total).

Step2:fit the full model.
```{r}
# fit the full model
bank_full_model <- lm(rev_total ~.,data=bank_revenue)

summary(bank_full_model)

plot(bank_full_model)
```
After we fitted the full model, we can found out the residual do not have a constant variance at every level of fitted value from the "residual v.s.fitted" plot. so we need to transform the response variable by using log or sqrt.

Step3: check the influence of the transformation on rev_total.
```{r}
bank_revenue %>%
  ggplot(aes(x=rev_total))+
  geom_histogram()

bank_revenue %>%
  ggplot(aes(x=log(rev_total)))+
  geom_histogram()

bank_revenue %>%
  ggplot(aes(x=sqrt(rev_total)))+
  geom_histogram()
```
Based on these comparison, we chose log transformation to normalize the response variable rev_total.

Step4: determining if the numeric predictor variables need to be transform as well.
```{r}
bank_revenue %>%
  ggplot(aes(x=rev_total,y=bal_total))+
  geom_point()

bank_revenue %>%
  ggplot(aes(x=log(rev_total),y=bal_total)) +
  geom_point()

bank_revenue %>%
  ggplot(aes(x=log(rev_total),y=log(bal_total)))+
  geom_point()
  
```
Based on this comparison,log transformation on bal_total significantly improves the linear relationship between bal_total and rev_total, we decide to use log for predict variable bal_total in our model.

```{r}
#Check if the age need to be transformed

bank_revenue %>%
  ggplot(aes(x=rev_total,y=age))+
  geom_point()

bank_revenue %>%
  ggplot(aes(x=log(rev_total),y=age))+
  geom_point()

bank_revenue %>%
  ggplot(aes(x=log(rev_total),y=log(age)))+
  geom_point()
```
Based on this comparison, log transformation on age does not improves the linear relationship between age and rev_total, we decide not to use log for predict variable age in our model.

```{r}
#Check if the account_age need to be transformed

bank_revenue %>%
  ggplot(aes(x=rev_total,y=account_age))+
  geom_point()

bank_revenue %>%
  ggplot(aes(x=log(rev_total),y=account_age))+
  geom_point()

bank_revenue %>%
  ggplot(aes(x=log(rev_total),y=log(account_age)))+
  geom_point()
```

Based on this comparison, log transformation on account_age does not improves the linear relationship between account_age and rev_total, we decide not to use log for predict variable account_age in our model.


Step 5: rebuild the full model with the transformed rev_total and bal_total.
```{r}
#make log of zero values to be 0.
update_bank_revenue <- bank_revenue %>%
  mutate(rev_total= if_else(rev_total==0,0,log(rev_total)),
         bal_total=if_else(bal_total==0,0,log(bal_total)))

# build the new full model
new_full_model <- lm(rev_total~., data = update_bank_revenue)

summary(new_full_model)

plot(new_full_model)
```

Step 6: reduce the new full model by using "stepwise" method.
```{r}
step <- stepAIC(new_full_model,direction = "both")

summary(step)

```
After we stepwise the new model, we checked the linear regression assumptions and found out that the new model met the homescedasticity and met the normality assumptions. so we do not need to further adjust on this model.

We can see the R^2 value of the new full model is 0.5963, and the stepwise model R^2 value is 0.5961, which are significantly higher than the previous full model. Also, the adjusted R^2 of the stepwise model is 0.5958, which is slightly better than the new full model (adjusted R^2 = 0.5957). But compared to the new full model, every predict variables in the stepwise model now has significant contribution (p<0.05).


Step 7: we will check the stepwise model's multicollinearity between the predict variables.
```{r}
vif <- car::vif(step) 
vif
```

We don't find predict variables with significant high vif value (e.g. vif >10), so, we don't need to further remove any predict variables.


Step 8: Check the assumptions 
We need to validate the assumption made when we creating our model using residual plot.
First, we will check for heteroskedasticity, to do this we will create a scaterplot of the residuals and the predicted values or the residuals and one predict varaible (e.g. bal_total).
```{r}
# Residual and the predict variables
update_bank_revenue %>%
  ggplot(aes(x=fitted(step),y=residuals(step))) +
  geom_point()+
  labs(title = "Residual v.s Predict Variable")
```

```{r}
# Residuals and one predcit variable (bal_total) 
update_bank_revenue %>%
  ggplot(aes(x=bal_total, y= residuals(step))) +
  geom_point()+
  labs(title="Residuals v.s One Predict Variable")
```

From the plots above, we can conclude that the homoscedasticity assumption was met.

Next, we want to check the normality of the residuals.
```{r}
update_bank_revenue %>%
  ggplot(aes(x=residuals(step))) +
  geom_histogram()+
  labs(title = "Distribution of Residuals")
```
We can conclude the assumption of the normality was met. 


Step 9: Finally, we would like to see if there any outlier need to be removed.
```{r}
#To correct these outlier we can find out IQR and then use those measurements to remove points
##Find Q1, Q3, and interquartile range (IQR) for values

Q1 <- quantile(update_bank_revenue$rev_total, .25)
Q3 <- quantile(update_bank_revenue$rev_total, .75)
IQR <- IQR(update_bank_revenue$rev_total)

#only keep rows in dataframe that have values within 1.5*IQR of Q1 and Q3
no_outliers <- subset(update_bank_revenue, update_bank_revenue$rev_total > (Q1 - 1.5*IQR) & update_bank_revenue$rev_total < (Q3 + 1.5*IQR))

head(no_outliers)
```
```{r}
# rebuid the model without outliers
model <- lm(rev_total ~., data = no_outliers)

summary(model)

plot(model)
```
We can conclude that there is no necessary to remove the outliers, because the R^2 =0.58 which is smaller than the stepwise model. 



Final conclusion:

Our final model to predict rev_total:
log(rev_total)= -2.62 + 0.15*offer + 1.59*card – 0.12*loan – 0.08*insur – 1.42*check + 0.45*log(bal_total). 
R^2 = 0.5963, Adjusted R^2 = 0.5958, All the assumptions for linear regression model are confirmed to be met. 
If a bank want to increase the total revenue generated by the customer over a 6-month period, they should consider increasing the using amount of the offer, the credit card activities and total of all account balance, while decreasing the customer activities from personal loan, insurance account and checking account. 














